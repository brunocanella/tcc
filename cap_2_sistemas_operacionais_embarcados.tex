\chapter{Sistemas Operacionais Embarcados}

O presente capítulo inicia abordando o tema de sistemas operacionais e sobre como estes atuam em ambientes computacionais, mantendo um foco mais voltado aos de uso pessoal.

%TODO falar sobre Associar veiculos a sistemas embarcados
Na sequência, há uma breve discussão sobre o que são sistemas embarcados, onde podemos encontrá-los  e como podemos classifica-los. Uma discussão sobre as funcionalidades que um sistema embarcado pode agregar aos sistemas veiculares é realizada no capítulo . %\ref{cap:automacao_veicular}.

Definidos estes conceitos, um modelo de estrutura para um sistema operacional é apresentado, mostrando e detalhando os principais componentes que o compõem.

Em seguida, o conceito de sistemas de tempo real é agregado ao trabalho, apresentando uma definição para o mesmo, bem como exemplificando casos que justifiquem a sua associação para com projetos veiculares. O conceito de sistemas operacionais embarcados é então conformado para um padrão que atenda as especificações de um projeto com restrições temporais.

Por fim, são apresentados exemplos de sistemas operacionais em tempo real, buscando destacar o que eles apresentam em termos de inovação ou funcionalidade.

\section{Sistemas Operacionais}

Em seu livro sobre sistemas operacionais, \citeonline{minix} explica que um computador é composto por um ou mais processadores, uma memória principal e dispositivos de entrada e saída. O sistema operacional tem por objetivo controlar os recursos do computador e prover a base na qual as aplicações podem ser escritas. Esta base disponibiliza uma interface para o programador de aplicativos, que atua como um meio de acesso a funções de mais baixo nível e ao hardware.

Ele também menciona que definir um sistema operacional é uma tarefa difícil, e que parte do problema se deve ao fato de ele realizar duas funções distintas: expandir a máquina e gerenciar recursos.

Expandir a máquina se refere á abstração feita sobre o seu hardware, escondendo as complexidades e facilitando a sua manipulação através de uma interface de mais alto nível. 

Gerenciar recursos se refere ao compartilhamento destes em tempo e espaço. Em tempo pode ser exemplificado por um sistema que precisa executar diversas tarefas ao mesmo tempo em um computador mas onde apenas uma delas pode estar ativa. Neste caso, o sistema operacional alterna em dados intervalos de tempo qual processo estará sendo executado. Impedir o acesso á áreas de memória reservada ou ainda permitir que mais de um processo aloque a impressora são exemplos da gerenciamento de recursos em espaço.

\section{Sistemas Embarcados}

De forma objetiva, \citeonline{prog_emb_sys} definem um sistema embarcado como uma combinação de hardwares e softwares computacionais em possível conjunto com partes mecânicas e/ou eletrônicas, integrados para realizar uma função dedicada.

\citeonline{hallinan} expande esta definição descrevendo uma série de características que ajudam a classificar quando um sistema pode ser considerado embarcado, sendo elas:

\begin{itemize}
	\item Possuir um mecanismo de processamento, tal como um microcontrolador de uso geral;
	\item Tipicamente projetados para uma aplicação ou propósito específico;
	\item Oferecem, opcionalmente, uma interface de usuário simples como, por exemplo, um controle de ignição para um motor automotivo;
	\item Frequentemente possuem recursos limitados. A exemplo, eles podem ter uma memória principal pequena e nenhum disco-rígido;
	\item Podem ter um suprimento limitado de energia, como em um sistema alimentado por baterias;
	\item Tipicamente, não são utilizados como plataformas computacionais de propósito geral;
	\item Geralmente possuem aplicativos de software pré-instalados, sem seleção do usuário;
	\item São distribuídos com todas as aplicações de software e hardware pré-integrados;
	\item Comumente são projetados para aplicações onde não há intervenção humana;
\end{itemize}

Na maioria dos casos, os sistemas embarcados são limitados em recursos quando comparados ao tipico computador de uso geral. Os sistemas embarcados geralmente possuem memória limitada, pequeno ou nenhum espaço de disco rígido e, algumas vezes, nenhuma forma de conectividade com redes externas. Frequentemente, as únicas interfaces com o usuário são uma porta serial e alguns LEDs\footnote{Light Emitting Diode ou Diodo Emissor de Luz}\cite{hallinan}.

\citeonline{qingli} fala que sistemas embarcados são encontrados em uma variedade infinita de tipos, cada qual exibindo caracteristicas únicas. A exemplo, ele cita que a maioria dos veículos em transito, hoje em dia, imbuem chips de computadores, os quais executam tarefas que agregam funcionalidades aos veículos, tornando-os mais fáceis, objetivos, seguros e agradáveis de dirigir. Outros exemplos seriam: telefones, casas inteligentes, sistemas de segurança, aparelhos de televisão a cabo e a satélite, sistemas de \emph{home theater}, secretária eletrônica, dentre muitos outros.

\section{Componentes de um Sistema Operacional Embarcado}

%TODO Escrever esta parte
Paradas que compõem um \emph{kernel}. O conteúdo que segue foi adaptado do livro de \citeonline{qingli}. Informações provenientes de outros autores estarão devidamente citados.

\subsection{Gerenciamento de Tarefas}

Tarefas são threads de execução independentes que competem entrem si para se tornarem o processo ativo no processador. As aplicações são decompostas em múltiplas tarefas concorrentes para optimizar a manipulação de entradas e saídas atendendo a uma restrição temporal.

Uma tarefa precisa ser agendável. Ela deve ser capaz de competir pelo tempo de execução em um sistema, baseado em um algoritmo de agendamento, como \emph{round-robin} ou por prioridades. Uma tarefa é definida pelo seu distinto conjunto de parâmetros e estruturas de dado que a suportam. Ao ser criada, uma tarefa recebe um identificador único, uma prioridade, uma estrutura de contexto e uma rotina que será executada sempre que a tarefa estiver em execução. Um exemplo de estrutura para uma tarefa pode ser visto no algoritmo \ref{alg:struct_task}.

\begin{listing}
	\caption{Estrutura de uma Tarefa.}
	\label{alg:struct_task}
	\centering
	\begin{minted}[mathescape,linenos,numbersep=5pt,gobble=0,frame=lines,framesep=2mm]{c++}
typedef struct task_s {
	int id;
	int priority;
	state_t state;
	context_t context;
	void (*function)();	
} task_t;
	\end{minted}
\end{listing}

Além de prover a estrutura para um objeto do tipo \emph{tarefa}, o \emph{kernel} também é responsável por oferecer serviços que manipulam estes objetos. Estes serviços incluem ações que o \emph{kernel} realiza sigilosamente para suportar as tarefas como, por exemplo, criar e manter o bloco de controle e pilha de uma tarefa.

O \emph{kernel} também deve prover uma API\footnote{Application Programming Interface - Interface de Programação de Aplicação} que permita ao desenvolvedor manipular as tarefas. Algumas das operações mais comuns que os desenvolvedores podem realizar em uma tarefa incluem:

\begin{itemize}
	\item Criar e excluir;
	\item Controlar o agendamento;
	\item Recuperar informações.
\end{itemize}

Uma tarefa pode ser destinada a realizar tanto uma atividade do sistema quanto uma funcionalidade implementada pelo usuário final. Qualquer que seja seu propósito, uma tarefa possuí um conjunto de estados, os quais definem o seu comportamento no sistema. Dentre os mais comuns estão os estados de: \emph{pronto}, \emph{rodando} e \emph{bloqueado}.

\begin{itemize}
	\item \textbf{Pronto}: A tarefa está pronta para execução e está a espera do escalonador de processos;
	\item \textbf{Rodando}: A tarefa foi escolhida pelo escalonador e está efetivamente em execução;
	\item \textbf{Bloqueado}: A tarefa está aguardando a liberação de algum recurso antes que possa prosseguir sua execução.
\end{itemize}

\emph{Pronto} é  sempre o estado inicial de uma tarefa. Dependendo do tipo de tarefa, ela pode executar em um looping infinito ou até que ela encerre. Neste ultimo caso, a tarefa é removida da lista de processos aptos. Uma tarefa só pode mudar seu estado para bloqueado quando ela for a tarefa em execução. Uma tarefa que está bloqueada, e cujo recurso foi liberado, pode apenas retornar para a fila de espera e aguardar que o escalonador a coloque em execução novamente.

A figura \ref{fig:tarefa_estados} apresenta uma ilustração das transições de estado que uma tarefa pode fazer.

\begin{figure}[htb]
	\centering
	\includegraphics[width=\textwidth]{task_states.png}
	\caption{Transição de Estados para Tarefas.}
	\label{fig:tarefa_estados}
\end{figure}

\subsubsection{Fibra}

Uma variante das tarefas são as fibras\footnote{Fiber}, que são threads de execução leves e não-preemptivas, normalmente utilizadas para executar porções de código responsáveis pelos dispositivos de drivers e outros trabalhos de performance crítica \cite{rocket}.

\subsubsection{Semáforos}

Múltiplas \emph{threads} de execução concorrentes em uma aplicação devem serem capazes de sincronizar suas execuções e coordenar o acesso mutuamente exclusivo a recursos compartilhados. Para atender a estes requisitos, os \emph{kernels} provêm um objeto chamado semáforo e respectivos serviços associados a este.

Um semáforo é um objeto do \emph{kernel} que uma ou mais threads de execução podem reservar ou liberar, para o propósito de sincronização ou exclusão mútua. Os elementos que compõem um semáforo são: um identificador único, um contador e uma fila de tarefas em espera. Um exemplo de estrutura de um semáforo pode ser visto no algoritmo \ref{alg:struct_semaphore}.

\begin{listing}
	\caption{Estrutura de uma Semáforo.}
	\label{alg:struct_semaphore}
	\centering
	\begin{minted}[mathescape,linenos,numbersep=5pt,gobble=0,frame=lines,framesep=2mm]{c++}
typedef struct semaphore_s {
	int id;
	int value;
	queue_t waiting_tasks;
} semaphore_t;
	\end{minted}
\end{listing}

Um semáforo funciona como uma espécie de chave que permite a uma tarefa acessar algum tipo de operação ou recurso. Se a tarefa puder adquirir um semáforo, ela poderá continuar sua execução normalmente.

Um semáforo pode ser reservador um número finito de vezes. Uma vez que seu valor máximo seja alcançado, as tarefas que tentarem adquirir este semáforo serão enviadas para uma lista de espera, onde permanecerão até que uma tarefa que tenha alocado previamente o semáforo o libere. Assim que se torna disponível, o semáforo é realocado para a primeira tarefa na fila de espera, caso haja alguma. Do contrário, seu valor re-incrementa.

Os semáforos aqui apresentados são os de contagem, binário e de exclusão mútua. Semáforos de contagem e binários apresentam comportamentos similares e respeitam as restrições impostas anteriormente, tendo como única diferença que um semáforo binário possui seu valor máximo igual a $1$. Os diagramas de estados destes dois modelos podem ser visualizados nas figuras \ref{fig:semaphore_binary} e \ref{fig:semaphore_counting}.

\begin{figure}[htb]
	\centering
	\includegraphics[width=\textwidth]{semaphore_binary.png}
	\caption{Transição de Estados para Semáforos Binários.}
	\label{fig:semaphore_binary}
\end{figure}

\begin{figure}[htb]
	\centering
	\includegraphics[width=\textwidth]{semaphore_counting.png}
	\caption{Transição de Estados para Semáforos Numéricos.}
	\label{fig:semaphore_counting}
\end{figure}

\subsubsection{Mutex}

Um terceiro tipo de semáforo trata de um caso especial do semáforo binário, chamado de \emph{semáforo de exclusão mútua} ou \emph{mutex}.  Um \emph{mutex} pode suportar propriedades de posse, trava recursiva, deleção segura de tarefas, dentre outros protocolos para evitar problemas inerentes a exclusão mútua.

\pagebreak

\begin{itemize}
%	\setlength\itemsep{1mm}
	\item \textbf{Posse}: Quando uma tarefa aloca um \emph{mutex}, ela se torna seu proprietário até que ela libere este recurso. Contrário aos semáforos, onde qualquer tarefa pode liberar o recurso, inclusive uma tarefa que não alocou o semáforo, apenas a tarefa proprietária poderá liberar o \emph{mutex}.
	\item \textbf{Trava Recursiva}: Permite a tarefa que alocou o \emph{mutex} realizar chamadas adicionais para trava-lo novamente. Um contador interno é utilizo para manter o registro da quantidade de vezes que o recurso foi alocado para a tarefa proprietária. O \emph{mutex} só volta a ser liberado quando a tarefa proprietária chama um número igual de vezes a rotina de liberação deste recurso.
	\item \textbf{Deleção segura}: A deleção prematura de uma tarefa pode ser evitada utilizando uma trava de deleção para quando a tarefa trava e destrava um \emph{mutex}. Ativar esta propriedade garante que uma tarefa que for proprietária do \emph{mutex} não possa ser excluída até que o mesmo seja liberado.
	\item \textbf{Anulação de Inversão de Prioridade}: Dado o cenário onde uma tarefa de prioridade inferior que aloca um \emph{mutex}, e onde uma tarefa de prioridade maior está aguardando que ele seja liberado, mas que está sendo ofuscada por uma terceira tarefa de prioridade mediana, ocorre o que é chamado de \emph{Inversão de Prioridade}, pois a tarefa mais prioritária passaria a ser aquela que alocou o \emph{mutex}. Algumas técnicas para evitar estas situações são: elevar a prioridade da tarefa que aloca o \emph{mutex} ao máximo ou ainda por herança de prioridade da tarefa que ficar bloqueada por aguardar o \emph{mutex}.
\end{itemize}

Contrário aos estados de \emph{disponivel}/\emph{indisponivel} dos semáforos de contagem/binários, os estados de um \emph{mutex} são \emph{destravado} e \emph{travado}, representados por $0$ e $1$ respectivamente. Um \emph{mutex} é inicialmente criado em seu estado \emph{destravado}, no qual ele pode ser reservado por uma tarefa. Após a alocação, o \emph{mutex} passa para o estado \emph{travado}. Reciprocamente, quando a tarefa libera o \emph{mutex}, este retorna para o estado \emph{destravado}. A figura \ref{fig:semaphore_mutex} mostra o diagrama de estados para um \emph{mutex} com e sem travamento recursivo.

\begin{figure}[htb]
	\centering
	\includegraphics[width=\textwidth]{semaphore_mutex.png}
	\caption{Transição de Estados para Mutex.}
	\label{fig:semaphore_mutex}
\end{figure}

\subsubsection{Filas de Mensagens}

Uma fila de mensagens é um objeto através do qual as tarefas e ISRs\footnote{Interrupt Service Routines - Rotinas de Serviço para Exceções} enviam e recebem mensagens para comunicação e sincronização de dados. Uma fila de mensagens é uma espécie de pipeline. Ela armazena temporariamente as mensagem do remetente até que o destinatário esteja pronto para recebe-las. % Esta bufferização temporária desacopla uma tarefa emissora e receptora; isto é, ela libera a tarefa de ter que enviar e receber mensagens simultaneamente.

%Assim como os semáforos, uma fila de mensagens tem diversos componentes que o \emph{kernel} utiliza para gerenciar a fila.
Quando uma fila de mensagens é criada, ela recebe um QCB\footnote{Queue Control Block - Bloco de Controle de Fila} contendo: um identificar único, uma fila e contador para mensagens e uma fila e contador para tarefas em espera, caso requisições bloqueantes sejam suportadas. Um exemplo de implementação para uma fila de mensagens pode ser visto no \refalg{struct_message_queue}.

\begin{listing}
	\caption{Estrutura de uma Fila de Mensagens.}
	\label{alg:struct_message_queue}
	\centering
	\begin{minted}[mathescape,linenos,numbersep=5pt,gobble=0,frame=lines,framesep=2mm]{c++}
typedef struct message_element_s {
	unsigned char message[MAX_MESSAGE_LENGHT];	
} message_element_t;

typedef struct message_queue_s {
	int id;
	int tasks_size;
	task_t tasks[MAX_TASKS_QUEUE];
	int message_elements_size;
	message_element_t message_elements[MAX_MESSAGES_QUEUE];
} message_queue_t;
	\end{minted}
\end{listing}

A fila de mensagens é composta por objetos chamados de \emph{elementos}, dos quais cada um pode armazenar uma única mensagem. Os \emph{elementos} contendo a primeira e ultima mensagens são chamados de cabeça e cauda, respectivamente. Alguns elementos da fila podem estar vazios (não contêm uma mensagem). O número total de elementos (vazio ou não) na fila é o comprimento total da fila, representando em \refalg{struct_message_queue} como \emph{MAX\_MESSAGES\_QUEUE}. Uma outra possibilidade seria permitir que o desenvolvedor especificasse os tamanhos das filas quando uma fila de mensagens for criada. A \reffig{messages_queues} apresenta um esquema para as filas de mensagem.

\figura{messages_queues}{Esquema de uma Fila de Mensagens}

\paragraph{Estados em uma Fila de Mensagens}

O estado inicial para uma fila de mensagens é \emph{Vazio}. Se uma tarefa tentar receber uma mensagen de uma fila de mensagens vazia, a tarefa bloqueará e, se ela assim desejar, será mantida na fila de tarefas esperando, a qual pode ser tanto uma FIFO\footnote{First In, First Out - Primeiro que entra é o primeiro que sai} ou ainda baseado em prioridade.

Nesta situação, se outra tarefa enviar uma mensagem para a fila de mensagens, a mensagem é entregue diretamente para a tarefa bloqueada. A tarefa bloqueada é então removida da lista de tarefas em espera e redesignada para o estado de \emph{Pronto}. A fila de mensagens volta a ficar vazia.

Uma fila de mensagens passa para o estado \emph{Parcial} quando a fila de tarefas estiver vazia e, estando no estado \emph{Vazio}, uma mensagem for recebida.

Conforme mensagens adicionais chegam a esta fila, ela eventualmente enche até o ponto em que esgota seu espaço livre. A partir deste ponto, o número de mensagens na fila é igual ao seu limite máximo, e o estado da fila de mensagens se torna \emph{Cheio}. 

Enquanto a fila de mensagens estiver neste estado, quaisquer tarefas enviando mensagens para ela irão falhar, a menos que alguma outra tarefa requisite primeiro uma mensagem daquela fila, efetivamente liberando um elemento da fila. O reciproco também é verdade para fila em estado \emph{Vazio} em que tarefas tentem receber mensagens. A \reffig{messages_states} contém um diagrama apresentando a mudança de estados em uma fila de mensagens.

\figura{messages_states}{Estados da Fila de Mensagens}

\subsubsection{Pipes}

\emph{Pipes} são objetos do \emph{kernel} que provêm a troca de dados não estruturada e que facilitam a sincronização entre tarefas. Em uma implementação tradicional, um \emph{pipe} é um facilitador para troca de dados de maneira unidirecional, conforme visto na \reffig{pipes_schema}. Dois descritores, um para cada extremidade do \emph{pipe} são retornados quando um \emph{pipe} é criado. Um dos descritores fica responsável pela escrita, enquanto o outro é destinado a leitura. Os dados permanecem no \emph{pipe} como um \emph{array} de \emph{bytes} não estruturados. Os dados são lidos do \emph{pipe} em \emph{FIFO}.

\figura{pipes_schema}{Esquema de um Pipe}

Um \emph{pipe} provê um fluxo de dados simples, de forma que o leitor fique bloqueado enquanto o \emph{pipe} estiver vazio, assim como o escritor permanecerá bloqueado enquanto um \emph{pipe} estiver cheio. Tipicamente, um \emph{pipe} é utilizado para trocar dados entre uma tarefa produtora e uma tarefa consumidora, conforme mostrado na \reffig{pipes_transmission}. Também é possível haverem diversos escritores e leitores para um mesmo \emph{pipe}.

\figura{pipes_transmission}{Modelo de transmissão para Pipes}

Um \emph{pipe}, embora bastante similar a uma \emph{fila de mensagens}, possui diferenças significantes que a tornam um elemento único. Como exemplo, ao contrário de uma \emph{fila de mensagens}, um \emph{pipe} não pode armazenar multiplas mensagens. Ao invés, os dados nele armazenados não possuem estrutura, mas consistem em um fluxo de \emph{bytes}. Outra diferença é que os dados em um pipe não podem ser priorizados; o fluxo de dados é estreitamente \emph{FIFO}. Finalmente, os pipes oferecem a função de \emph{seleção}, que permitem que uma tarefa permaneça bloqueada até que uma condição ocorra em um ou mais \emph{pipes}.

\paragraph{Bloco de Controle para Pipes}

As informações especificas para objetos do tipo \emph{pipe} são mantidas em uma estrutura chamada de \emph{PCB}\footnote{Pipe Control Block - Bloco de Controle para Pipes}. Esta estrutura, em uma forma geral, contém um \emph{buffer} de dados alocado pelo \emph{kernel} para suas operações de entrada e saída. O tamanho deste \emph{buffer} é mantido no bloco de controle e se torna fixo após a criação do \emph{pipe}. A contagem de \emph{bytes} no \emph{buffer}, em conjunto com os cursores\footnote{posição no buffer} de entrada e saída, também são partes do bloco de controle. A contagem de \emph{bytes} representa a quantidade dados legível no \emph{pipe}. O cursor de entrada especifica onde a proxima operação de escrita deverá ocorrer. Similarmente, o cursor de saída indica onde a próxima leitura ocorrerá. O \emph{kernel} cria e retorna dois descritores, que são únicos para o sistema de entrada/saída. A \reffig{pipes_pcb} apresenta um modelo gráfico de um \emph{PCB}, enquanto que o \refalg{pipes_pcb} demonstra um exemplo de implementação.

\figura{pipes_pcb}{Bloco de controle do Pipe}

\begin{listing}
	\caption{Bloco de controle do Pipe.}
	\label{alg:pipes_pcb}
	\centering
	\begin{minted}[mathescape,linenos,numbersep=5pt,gobble=0,frame=lines,framesep=2mm]{c++}
typedef struct pcb_s {
	uint32_t byte_count;
	byte* buffer;
	uint32_t buffer_size;
	byte* cursor_input;
	byte* cursor_output;	
} pcb_t;
	\end{minted}
\end{listing}

\paragraph{Estados de um Pipe}

Um \emph{pipe} possui um número limitado de estados. Cada um corresponde a um estado de transmissão de dados entre os leitores e escritores do \emph{pipe}, conforme ilustrado pela \reffig{pipes_states}.

\figura{pipes_states}{Estados de um Pipe}

\paragraph{Operações para Pipes}

Algumas das operações para \emph{pipes} são:

\begin{itemize}
	\item Criar e excluir;
	\item Ler e escrever no pipe;
	\item Emitir comandos de controle;
	\item Realizar uma seleção.
\end{itemize}

Destes, o comando de \emph{seleção} é o que mais se destaca, sendo um dos diferenciais entre \emph{pipes} e \emph{filas de mensagens}. Ela permite que uma tarefa bloqueie e aguarde que uma condição especifica ocorra em um ou mais \emph{pipes}. A condição de aguardo pode ser a espera pela disponibilidade de dados ou pelo esvaziamento de um \emph{pipe}. A \reffig{pipes_select} ilustra o cenário no qual uma única tarefa está esperando para ler de dois \emph{pipes} e escrever em um terceiro. Neste caso, o método \emph{seleção} retornará quando os dados estivem disponíveis em quaisquer um dos dois \emph{pipes}. A mesma chamada a função \emph{seleção} também retornará quando um espaço para escrita estiver disponível no \emph{pipe} inferior. Em geral, uma tarefa lendo de múltiplos \emph{pipes} pode realizar uma operação de \emph{seleção} neles, e o método retornará quando qualquer um deles estiver disponível. Similarmente, uma tarefa escrevendo em múltiplos \emph{pipes} pode realizar uma operação de \emph{seleção} sobre os \emph{pipes}, e o método retornará quando surgir um espaço em qualquer um deles.

\figura{pipes_select}{Operação de seleção em múltiplos pipes}

\subsubsection{Registrador de Eventos}

Alguns \emph{kernels} oferecem um tipo especial de registrador como parte do \emph{bloco de controle de uma tarefa}. Este registrador, chamado de \emph{Registrador de Eventos}, pertence a tarefa e consiste em um grupo de \emph{flags} binárias utilizadas para registrar a ocorrência de eventos específicos. Dependendo da implementação do \emph{kernel}, um registrador para eventos pode reservar um espaço entre $8$ à $32$ bits. Cada bit no registrador de eventos é tratado como uma \emph{flag} binária (também conhecida como uma \emph{flag} de evento) e pode estar ativa ou não. A \reffig{events_schema} ilustra o esquema de um registrador de eventos.

\figura{events_schema}{Esquema de um \emph{Registro de Eventos}}

Uma tarefa pode verificar, através do registrador de evento, se houve a ativação de um evento em particular, o qual define sua execução. Uma fonte externa, tal como outra tarefa ou \emph{ISR} podem ativar os bits no registrador de evento para informarem a tarefa que um evento em particular ocorreu.

\paragraph{Bloco de Controle para um Registrador de Eventos}

O bloco de controle para um registrador de eventos geralmente é implementado como parte do bloco de controle de uma tarefa.

A tarefa especifica o conjunto de eventos que ela deseja receber. Este conjunto fica no registrador de eventos desejados. De maneira similar, os eventos recebidos são mantidos no no registrador de eventos recebidos. Uma tarefa pode especificar um temporizador para determinar quanto tempo ela deseja esperar pela chegada de tal evento. O \emph{kernel} desperta a tarefa caso o tempo de espera tenha passado e nenhum dos eventos especificados tenha chego até a tarefa.

Utilizando as condições de notificação, a tarefa informa o \emph{kernel} quando ela deseja ser notificada uma vez que um evento ocorra. Por exemplo, uma tarefa pode especificar a condição de notificação como uma combinação de eventos do tipo 1 e 2 ou ainda quando um evento de tipo 3 ocorrer.

\paragraph{Operações Comuns em Registradores de Eventos}

As duas operações mais comuns a registradores de eventos são as de: enviar um evento e receber eventos.

A operação de recebimento permite que a tarefa que fez a chamada receba eventos de uma fonte externa. Na chamada da função, pode-se especificar um conjunto de eventos e uma condição do tipo \emph{E}/\emph{OU} para que a rotina retorne com sucesso. No caso da operação \emph{E}, todos os eventos devem estar presentes para que a função retorne. Já no caso da opção \emph{OU}, apenas um dos eventos precisa ocorrer para que a função retorne com sucesso.

A operação de recebimento possui versões bloqueantes por tempo ou até que o evento ocorra. No caso da versão por tempo, a tarefa aguarda até que uma quantidade de tempo, informada por parâmetro, tenha decorrido, para então retornar com uma condição de falha.

A função de envio permite que uma fonte externa, tanto uma tarefa ou uma \emph{ISR}, envie eventos para outra tarefa. O emissor pode enviar diversos eventos para a tarefa de destino através de uma única operação de envio. Eventos que foram enviados e que ainda não foram reconhecidos pela tarefa receptora serão sobre-escritos.

\paragraph{Separação por Tarefas}

Por causa de sua natureza não cumulativa, um registrador de eventos que possua diversas tarefas que possam \emph{setar} um mesmo tipo de flag podem sobre-escrever um sinal já existente, causando um comportamente indesejado. Uma maneira de evitar este comportamento é separando faixas de eventos por tarefa, dentro do registrador. Desta forma, cada tarefa fica limitada a um espaço de bits dentro do registrador, sem que haja qualquer interferência de outras tarefas. A \reffig{events_multitask} apresenta um esquema gráfico deste modelo.

\figura{events_multitask}{Registrador de Eventos com bits reservados para tarefas}

\subsubsection{Sinais}



\subsubsection{Variáveis Condicionais}

\subsubsection{Exceções e Interrupções}

\subsubsection{Temporizadores}

\subsection{Subsistemas de Entrada/Saída}

\subsection{Gerenciamento de Memória}

\subsection{Sistemas de Arquivos}


\section{Sistema de Tempo Real}

A real-time application is composed of multiple concurrent tasks that are independent threads of execution, competing on their own for processor execution time \cite{qingli}.

\section{Padrões para o Desenvolvimento de RTOS}

\section{Exemplos}
